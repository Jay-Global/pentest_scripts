import socket
import subprocess
import time

# Define ANSI color codes
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def scan_port(ip, port):
    """Attempt to connect to a specific port on a specified IP address."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        socket.setdefaulttimeout(1)  # Timeout for the socket operation
        result = sock.connect_ex((ip, port))
        sock.close()
        return result == 0  # Return True if the port is open, False otherwise
    except socket.error as e:
        print(f"{bcolors.FAIL}Socket error: {e}{bcolors.ENDC}")
        return False

def is_valid_ip(ip):
    """Validate if the input string is a valid IP address."""
    parts = ip.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if not 0 <= int(part) <= 255:
            return False
    try:
        socket.inet_aton(ip)  # This checks for any other invalid IP format issues
        return True
    except socket.error:
        return False

def analyze_results(filename):
    """Read the dirb results file and provide additional information."""
    common_directories = {
        "cgi-bin/": "Common directory for CGI scripts, often a target for exploitation.",
        "phpMyAdmin/": "phpMyAdmin interface, vulnerable if not properly secured.",
        "wp-admin/": "WordPress admin login, often targeted for brute force attacks.",
        "admin/": "Commonly used for administrative access to the web application.",
        "backup/": "Directory where backups might be stored, possibly containing sensitive data.",
        "uploads/": "Often used for file uploads, could be exploited if improperly secured.",
        "config/": "May contain configuration files with sensitive information.",
        "data/": "Directory where application data might be stored.",
        "logs/": "Access to logs might reveal sensitive information or application behavior.",
        "tmp/": "Temporary files, might be accessible if directory permissions are misconfigured.",
        "private/": "Intended to be private, but sometimes exposed due to misconfigurations.",
        "test/": "Used for testing purposes, may contain unfinished or unsecure code.",
        "old/": "Old versions of files or directories, possibly containing vulnerabilities.",
        "db/": "Database-related files, might be accessible and contain sensitive data.",
        "scripts/": "May contain various scripts used by the web application, potential for exploitation."
    }

    with open(filename, 'r') as file:
        lines = file.readlines()
        for line in lines:
            for directory in common_directories:
                if directory in line:
                    print(f"{bcolors.WARNING}Found directory '{directory}' - {common_directories[directory]}{bcolors.ENDC}")

def main():
    # ASCII Art and Welcome Message
    print(f"""{bcolors.OKCYAN}
    ***************************************************
    *               Welcome to WebScan!               *
    *       A simple script to scan web ports         *
    *      and enumerate hidden directories.          *
    ***************************************************
    {bcolors.ENDC}""")
    print(f"{bcolors.OKGREEN}To exit the script at any time, enter 'q' or 'Q'.{bcolors.ENDC}\n")

    # User input with validation for IP address or quit
    while True:
        target_ip = input(f"{bcolors.HEADER}Enter the target IP address: {bcolors.ENDC}")
        if target_ip.lower() == 'q':
            print(f"{bcolors.OKBLUE}Exiting the script. Goodbye!{bcolors.ENDC}")
            return
        if is_valid_ip(target_ip):
            break
        else:
            print(f"{bcolors.FAIL}Invalid IP address format. Please try again or enter 'q' to quit.{bcolors.ENDC}")
    
    ports_to_check = [80, 443]  # HTTP and HTTPS ports
    open_ports = []

    for port in ports_to_check:
        print(f"{bcolors.OKBLUE}Scanning port {port} on {target_ip}...{bcolors.ENDC}")
        if scan_port(target_ip, port):
            print(f"{bcolors.OKGREEN}Port {port} is open on {target_ip}.{bcolors.ENDC}")
            open_ports.append(port)
        else:
            print(f"{bcolors.WARNING}Port {port} is not open on {target_ip}.{bcolors.ENDC}")

    if open_ports:
        print(f"{bcolors.OKCYAN}Running dirb to find hidden directories for open ports: {open_ports}{bcolors.ENDC}")
        try:
            # Using subprocess to run dirb on the target IP for each open port with timestamped output file
            timestamp = time.strftime("%Y%m%d-%H%M%S")
            for port in open_ports:
                output_file = f"dirb_results_{port}_{timestamp}.txt"
                result = subprocess.run(["dirb", f"http://{target_ip}:{port}", "-o", output_file], capture_output=True, text=True)
                print(f"{bcolors.OKGREEN}Dirb scan complete for port {port}. Results saved to '{output_file}'.{bcolors.ENDC}")
                print(result.stdout)  # Optionally print the output from dirb

                # Analyze results for common directories
                analyze_results(output_file)

        except Exception as e:
            print(f"{bcolors.FAIL}Failed to run dirb: {e}{bcolors.ENDC}")
    else:
        print(f"{bcolors.WARNING}No open web ports detected. No need to run dirb.{bcolors.ENDC}")

if __name__ == "__main__":
    main()
